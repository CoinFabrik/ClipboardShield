using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace hash_generator
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] files =
            {
                //32-bit
                "./bin/ClipboardFirewallDll32.dll",
                "./bin/CFManualInjector32.exe",
                "./bin/InjectDll32.exe",
                //64-bit
                "./bin64/ClipboardFirewallDll64.dll",
                "./bin64/CFManualInjector64.exe",
                "./bin64/InjectDll64.exe",
            };
            var hashes = new List<string>();
            foreach (var file in files)
                using (var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read))
                    hashes.Add(BitConverter.ToString(SHA256.Create().ComputeHash(stream)).ToLower().Replace("-", ""));

            var sb = new StringBuilder();
            sb.Append("// This file is autogenerated. Do not edit.\n" + 
                "\n" +
                @"#include ""FileHash.h""" +
                "\n\n" +
                "extern const FileHash file_hashes[] = {\n"
            );
            Debug.Assert(hashes.Count == files.Length);
            for (int i = 0; i < hashes.Count; i++)
                sb.Append($@"    {{ L""{Path.GetFileName(files[i])}"", ""{hashes[i]}"" }}," + "\n");
            sb.Append(
                "    { nullptr, nullptr },\n" +
                "};\n"
            );

            var newString = sb.ToString();
            string oldString = null;

            const string outputFilePath = "libvts/hashes.cpp";

            try
            {
                using (var file = new StreamReader(outputFilePath))
                    oldString = file.ReadToEnd();
            }
            catch
            {
            }

            if (oldString == null || newString != oldString)
            {
                using (var file = new StreamWriter(outputFilePath))
                    file.Write(newString);
                Console.WriteLine($"{outputFilePath} updated.");
            }
            else
            {
                Console.WriteLine($"No changes detected. {outputFilePath} was not updated.");
            }
        }
    }
}
