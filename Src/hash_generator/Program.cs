using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using static System.Net.WebRequestMethods;

namespace hash_generator
{
    class Program
    {
        static IEnumerable<string> GenerateHashes(string[] files)
        {
            foreach (var file in files)
                using (var stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read))
                    yield return BitConverter.ToString(SHA256.Create().ComputeHash(stream)).ToLower().Replace("-", "");
        }

        static string GenerateCpp(string[] files, List<string> hashes)
        {
            Debug.Assert(hashes.Count == files.Length);

            var ret = new StringBuilder();
            ret.AppendLine("// This file is autogenerated. Do not edit.");
            ret.AppendLine();
            ret.AppendLine(@"#include ""FileHash.h""");
            ret.AppendLine();
            ret.AppendLine("extern const FileHash file_hashes[] = {");
            for (int i = 0; i < hashes.Count; i++)
                ret.AppendLine($@"    {{ L""{Path.GetFileName(files[i])}"", ""{hashes[i]}"" }},");
            ret.AppendLine("    { nullptr, nullptr },");
            ret.AppendLine("};");

            return ret.ToString();
        }

        static string GenerateCs(string[] files, List<string> hashes)
        {
            Debug.Assert(hashes.Count == files.Length);

            var ret = new StringBuilder();
            ret.AppendLine("// This file is autogenerated. Do not edit.");
            ret.AppendLine();
            ret.AppendLine("namespace hash_checker{");
            ret.AppendLine("    internal class Hashes{");
            ret.AppendLine("        public static (string, string)[] HashesByPath = new (string, string)[]{");
            for (int i = 0; i < hashes.Count; i++)
                ret.AppendLine($@"            (@""{Path.GetFullPath(files[i])}"", ""{hashes[i]}""),");
            ret.AppendLine("        };");
            ret.AppendLine("    }");
            ret.AppendLine("}");

            return ret.ToString();
        }

        static string ReadGeneratedFile(string path)
        {
            try
            {
                using (var file = new StreamReader(path))
                    return file.ReadToEnd();
            }
            catch
            {
                return null;
            }
        }

        static void GenerateFile(string outputFilePath, string[] files, List<string> hashes, Func<string[], List<string>, string> generator)
        {
            var newString = generator(files, hashes);
            var oldString = ReadGeneratedFile(outputFilePath);

            if (oldString == null || newString != oldString)
            {
                using (var file = new StreamWriter(outputFilePath))
                    file.Write(newString);
                Console.WriteLine($"{outputFilePath} updated.");
            }
            else
            {
                Console.WriteLine($"No changes detected. {outputFilePath} was not updated.");
            }
        }

        static void Main(string[] args)
        {
            string[] files =
            {
                //32-bit
                "./bin/ClipboardFirewallDll32.dll",
                "./bin/CFManualInjector32.exe",
                "./bin/InjectDll32.exe",
                //64-bit
                "./bin64/ClipboardFirewallDll64.dll",
                "./bin64/CFManualInjector64.exe",
                "./bin64/InjectDll64.exe",
            };

            var hashes = GenerateHashes(files).ToList();
            GenerateFile("libvts/hashes.cpp", files, hashes, GenerateCpp);
            GenerateFile("hash_checker/Hashes.cs", files, hashes, GenerateCs);
        }
    }
}
